# Table of Contents
- [ISO Dateien auf pfsense transferieren](#ISO Dateien auf pfsense transferieren)
- [Chapter 1: Getting Started](#chapter-1-getting-started)




# ISO Dateien auf pfsense transferieren

```powershell
ssh admin@192.168.100.2 mkdir -p /usr/local/www/iso
```
```powershell
cd C:\lab\vm\iso-images
```
```powershell
scp "C:\lab\vm\iso-images\*" admin@192.168.100.2:/usr/local/www/iso
```
```powershell
ssh admin@192.168.100.2 ls -l /usr/local/www/iso
```

# PXE Dienste

Ein PXE-Server (Preboot Execution Environment) benötigt mehrere wichtige Dienste, um das Netzwerk-Booten und die OS-Installation zu ermöglichen:

1. **DHCP-Server**: Stellt dem Client die Netzwerkkonfiguration bereit, wie z.B. die IP-Adresse, das Gateway und den Speicherort der Boot-Datei.

2. **TFTP-Server**: Überträgt die Boot-Dateien (z.B. `pxelinux.0`, `grubx64.efi`, `vmlinuz`, `initrd.img`) mithilfe des Trivial File Transfer Protocol an den Client.

3. **NFS-, HTTP- oder FTP-Server**: Hält die Installationsmedien des Betriebssystems oder Kickstart/Preseed-Dateien bereit, damit der Client die erforderlichen Dateien herunterladen kann, um die OS-Installation abzuschließen.

4. **Optional: DNS**: Nützlich, wenn die Installation oder Netzwerkkonfiguration eine Namensauflösung erfordert, aber nicht zwingend notwendig für ein grundlegendes PXE-Boot.

Diese Dienste arbeiten zusammen, um ein nahtloses Booten und Installieren über das Netzwerk zu ermöglichen.

## DHCP ist schon implementiert - bestätigen

```plaintext
webConfigurator http://192.168.100.2/
Services > DHCP Server > LAN
```

* General DHCP Options
  * Enable: `- [x] Enable DHCP server on LAN interface`
* Primary Address Pool: 
* Subnet: `192.168.100.0/24`
* Subnet Range: `192.168.100.1 - 192.168.100.254`
* Address Pool Range: `From 192.168.100.100 To 192.168.100.200`
* Server Options
  * DNS Servers: `1.1.1.1`
  * DNS Servers: `1.0.0.1`
* Other DHCP Options
  * TFTP > Display Advanced
    * TFTP Server: `192.168.100.2`
  * Network Booting > Display Advanced
    * Enable: `- [x] Enable Network Booting`
    * Next Server: `192.168.100.2`
    * Default BIOS File Name: `pxelinux.0`
    * UEFI 64 bit File Name: `efi/boot/grubx64.efi`
    * UEFI 64 bit File Name: `http://192.168.100.10/iso`
  * Custom DHCP Options > Display Advanced - ! Nicht nötig da wir oben die BIOS/EFI schon eingestellt haben !
    * Custom Option:
      * Number: `66`
      * Type: `Text`
      * Value: `192.168.100.2`
    * `+ Add Custom Option`
    * Custom Option:
      * Number: `67`
      * Type: `Text`
      * Value: Für BIOS: `pxelinux.0` Für EFI: `efi/boot/grubx64.efi`
 * Save
 * Apply Changes

Die BIOS-Clients erhalten automatisch `pxelinux.0`, und die EFI-Clients bekommen `efi/boot/grubx64.efi`, wie es in unsere Konfiguration vorgesehen ist. Der DHCP-Server erkennt automatisch, ob ein Client im BIOS- oder im EFI-Modus bootet, und sendet die entsprechende Boot-Datei. Deine Einstellungen sind korrekt.

Unser TFTP Server, welchen wir im nächsten Schritt implementieren werden, nutzt den Root Ordner: `/tftpboot/`
- `efi/boot/grubx64.efi` ist im absoluten Pfad: `/tftpboot/efi/boot/grubx64.efi`
- `pxelinux.0` ist im absoluten Pfad: `/tftpboot/pxelinux.0`

## TFTP implementieren

```plaintext
webConfigurator http://192.168.100.2/
System > Package Manager > Available Packages
```

* Search term: tftp
* Search
* Packages: tftpd
* `+ Install`
* Confirm

```plaintext
webConfigurator http://192.168.100.2/
Services > TFTP Server > Settings
```
* General Options
  * Enable TFTP service: `- [x] Check to enable the TFTP service.`
  * TFTP Server Bind IP: `192.168.100.2`
  * IPv4 Only:  `- [x] Check to allow clients to connect with IPv4 only.`
  * Logging: `- [x] Check to log read/write (RRQ/WRQ) requests.`
* Save

```plaintext
webConfigurator http://192.168.100.2/
Services > TFTP Server > Files
```
* Upload

TFTP Root Ordner wird standardmäßig dieser sein: `/tftpboot/`

# BIOS vs EFI Strukturen

In Windows die CentOS mounten: `C:\lab\vm\iso-images\CentOS-Stream-9-latest-x86_64-dvd1.iso`.
Wir werden die nötigen Dateien von dieser DVD auf unserem pfsense PXE Server transferieren.

## BIOS
- **BIOS Bootloader**: `pxelinux.0` wird im Verzeichnis `/tftpboot/` abgelegt.
  - **Pfad**: `/tftpboot/pxelinux.0`
- **BIOS Konfigurationsdatei**: Diese wird im Verzeichnis `/tftpboot/pxelinux.cfg/` gespeichert und heißt `default`.
  - **Pfad**: `/tftpboot/pxelinux.cfg/default`

## EFI
- **EFI Bootloader**: `grubx64.efi` wird im Verzeichnis `/tftpboot/efi/boot/` abgelegt.
  - **Pfad**: `/tftpboot/efi/boot/grubx64.efi`
- **EFI Konfigurationsdatei**: Diese wird ebenfalls im Verzeichnis `/tftpboot/efi/boot/` gespeichert und heißt `grub.cfg`.
  - **Pfad**: `/tftpboot/efi/boot/grub.cfg`

Das Platzieren dieser Bootloader-Dateien im Verzeichnis `/tftpboot` ist eine übliche und organisierte Methode, um alle PXE-Boot-Ressourcen an einem Ort zu verwalten. Hier ist, wie Sie es strukturieren können:

1. **Dateien, die nach `/tftpboot` kopiert werden sollen:**
   - `pxelinux.0` (Haupt-Bootloader-Datei für BIOS, die Sie aus dem `syslinux`-Paket erhalten sollten)
   - `ldlinux.c32`, `libcom32.c32`, `libutil.c32` und `vesamenu.c32` (unterstützende Module, die `pxelinux.0` benötigt, um ein Menü anzuzeigen)
   - `isolinux.cfg` (Sie können sie umbenennen und als `/tftpboot/pxelinux.cfg/default` verwenden, um sie als Ihre PXE-Menü-Konfigurationsdatei zu nutzen)
   - `vmlinuz` und `initrd.img` (Kernel- und Initrd-Images für Ihre Installationen)

2. **Dateienplatzierung in `/tftpboot`:**
   - Platzieren Sie alle erforderlichen Bootloader- und Moduldateien (`pxelinux.0`, `ldlinux.c32`, `libcom32.c32`, `libutil.c32`, `vesamenu.c32`) direkt im Verzeichnis `/tftpboot`.
   - Erstellen Sie eine Verzeichnisstruktur für Ihre Kernel- und Initrd-Images, z.B. `/tftpboot/centos`, `/tftpboot/fedora` usw., und legen Sie die `vmlinuz`- und `initrd.img`-Dateien in den entsprechenden Verzeichnissen ab.
   - Verwenden Sie `/tftpboot/pxelinux.cfg/default` als Ihre PXE-Konfigurationsdatei, die Boot-Optionen für jedes Betriebssystem enthält.

### Beispielstruktur in `/tftpboot`:
```
/tftpboot/
│
├── pxelinux.0
├── ldlinux.c32
├── libcom32.c32
├── libutil.c32
├── vesamenu.c32
│
├── pxelinux.cfg/
│   └── default  # Ihre PXE-Menü-Konfiguration
│
├── centos/
│   ├── vmlinuz
│   └── initrd.img
│
├── fedora/
│   ├── vmlinuz
│   └── initrd.img
│
└── weitere notwendige Dateien und Verzeichnisse...
```

### Zusätzliche Hinweise:
- **Berechtigungen**: Stellen Sie sicher, dass die Dateien die entsprechenden Berechtigungen haben, damit TFTP darauf zugreifen kann. Typischerweise ist `root:nobody` mit Lesezugriff für andere (`644`) ein guter Ausgangspunkt.
- **Konfigurationsdatei (`default`)**: Passen Sie `/tftpboot/pxelinux.cfg/default` an, um Boot-Optionen für die verschiedenen OS-Installationen einzuschließen und auf die richtigen `vmlinuz`- und `initrd.img`-Pfade zu verweisen.

Diese Einrichtung stellt sicher, dass Ihr PXE-Server das BIOS-Booten ordnungsgemäß handhaben kann, und die Zentralisierung aller Bootloader-Dateien in `/tftpboot` erleichtert die Verwaltung.

# BIOS vs EFI Strukturen erstellen

## BIOS
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/pxelinux.cfg/
```
```powershell
scp "C:\lab\vm\pxe\default" admin@192.168.100.2:/tftpboot/pxelinux.cfg/
```
```powershell
scp "C:\lab\vm\pxe\pxelinux.0" admin@192.168.100.2:/tftpboot/
```

### Ursprung 
Die Datei pxelinux.0 haben wir in dieser Repo doch diese kann von dem SYSLINUX-Paket abgerufen werden:

Ursprung: Linux-Paket

Red-Hat Distros:
```bash
sudo yum install syslinux
/usr/share/syslinux/pxelinux.0
```
Debian Distros:
```bash
sudo apt-get install syslinux-common
/usr/lib/syslinux/pxelinux.0
```

Ursprung: ISO-Image

## EFI
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/efi/boot/
```
```powershell
scp "D:\EFI\BOOT\grub.cfg" admin@192.168.100.2:/tftpboot/efi/boot/
```
```powershell
scp "D:\EFI\BOOT\grubx64.efi" admin@192.168.100.2:/tftpboot/efi/boot/
```
```powershell
ssh admin@192.168.100.2 chmod 644 /tftpboot/efi/boot/grub.cfg
```
```powershell
ssh admin@192.168.100.2 chmod 644 /tftpboot/efi/boot/grubx64.efi
```

## Ownership (root:nobody), Permissions (644) bestätigen
```powershell
ssh admin@192.168.100.2 find /tftpboot -print
```
```powershell
ssh admin@192.168.100.2 ls -lR /tftpboot/
```
```powershell
PS D:\isolinux> ssh admin@192.168.100.2 find /tftpboot -print
/tftpboot
/tftpboot/pxelinux.cfg
/tftpboot/pxelinux.cfg/default
/tftpboot/pxelinux.0
/tftpboot/efi
/tftpboot/efi/boot
/tftpboot/efi/boot/grub.cfg
/tftpboot/efi/boot/grubx64.efi
PS D:\isolinux> ssh admin@192.168.100.2 ls -lR /tftpboot/
total 46
drwxr-xr-x  3 root nobody     3 Nov  4 10:13 efi
-rw-r--r--  1 root nobody 42720 Nov  4 10:43 pxelinux.0
drwxr-xr-x  2 root nobody     3 Nov  4 10:48 pxelinux.cfg

/tftpboot/efi:
total 1
drwxr-xr-x  2 root nobody 4 Nov  4 10:19 boot

/tftpboot/efi/boot:
total 1037
-rw-r--r--  1 root nobody    1376 Nov  4 10:18 grub.cfg
-rw-r--r--  1 root nobody 2541096 Nov  4 10:19 grubx64.efi

/tftpboot/pxelinux.cfg:
total 5
-rw-r--r--  1 root nobody 948 Nov  4 10:48 default
PS D:\isolinux>
```

# Bootloader-Menus transferieren

Die Boot-Dateien sind auf der Centos ISO (unter D:\isolinux\) oder in dieser Repo vorhanden.

Diese Menus aus der CentOS ISO sind mit allen Distros kompatibel.

Ursprung: ISO-Image

```powershell
scp "C:\lab\vm\pxe\ldlinux.c32" admin@192.168.100.2:/tftpboot/
```
```powershell
scp "C:\lab\vm\pxe\libcom32.c32" admin@192.168.100.2:/tftpboot/
```
```powershell
scp "C:\lab\vm\pxe\libutil.c32" admin@192.168.100.2:/tftpboot/
```
```powershell
scp "C:\lab\vm\pxe\vesamenu.c32" admin@192.168.100.2:/tftpboot/
```
```powershell
scp "C:\lab\vm\pxe\menu.c32" admin@192.168.100.2:/tftpboot/
```

# Kernel (vmlinuz) und Initial RAM Disk Image (initrd.img) importieren

`vmlinuz` und `initrd.img` sind zwei essentielle Dateien, die beim Booten eines Linux-Systems verwendet werden:

1. **`vmlinuz`**: 
   - `vmlinuz` steht für "Virtual Memory LINUx gZip-compressed" und ist der Kernel des Betriebssystems in einer komprimierten Form.
   - Es ist der Hauptkern von Linux, der vom Bootloader (wie `pxelinux.0` oder `grubx64.efi`) geladen wird, um das Betriebssystem zu starten.
   - Während des Bootvorgangs wird `vmlinuz` entpackt und in den Speicher geladen, um die Kontrolle über die Hardware und den weiteren Bootvorgang zu übernehmen.

2. **`initrd.img`**:
   - `initrd.img` steht für "Initial RAM Disk Image" und ist eine Datei, die ein minimales Dateisystem enthält.
   - Es wird während des Bootvorgangs in den Speicher geladen und stellt Treiber sowie andere notwendige Dateien bereit, die zum Mounten des eigentlichen Wurzel-Dateisystems benötigt werden.
   - `initrd.img` ist besonders wichtig für Systeme, die Hardwaretreiber benötigen, bevor das Haupt-Dateisystem verfügbar ist (z.B. für Festplattencontroller oder Netzwerkgeräte).

### Zusammengefasst:
- **`vmlinuz`** ist der Linux-Kernel, der das Betriebssystem steuert.
- **`initrd.img`** ist ein temporäres Dateisystem, das dem Kernel hilft, die Hardware zu initialisieren und das eigentliche Wurzel-Dateisystem zu mounten.

Diese beiden Dateien arbeiten zusammen, um den Bootvorgang eines Linux-Systems zu ermöglichen.

## vmlinuz und initrd.img von jeder ISO-Image des jeweiligen Betriebssystems transferieren

Ursprung: ISO-Image

```plaintext
Centos:
D:\images\pxeboot\vmlinuz
D:\images\pxeboot\initrd.img

Fedora:
D:\images\pxeboot\vmlinuz
D:\images\pxeboot\initrd.img

Ubuntu:
D:\casper\vmlinuz
D:\casper\initrd

Debian:
D:\install.amd\vmlinuz
D:\install.amd\initrd.gz

Kali:
D:\install.amd\vmlinuz
D:\install.amd\initrd.gz
```

## OS-Ordner erstellen und kopieren

Zuerst die Betriebssystem-Ordnerstruktur erstellen:
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/centos
```
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/fedora
```
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/ubuntu
```
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/debian
```
```powershell
ssh admin@192.168.100.2 mkdir -p /tftpboot/kali
```

Danach kopieren (centos/fedora als Beispiel):
```powershell
scp "D:\images\pxeboot\vmlinuz" admin@192.168.100.2:/tftpboot/centos/
```
```powershell
scp "D:\images\pxeboot\initrd.img" admin@192.168.100.2:/tftpboot/centos/
```
```powershell
scp "E:\images\pxeboot\vmlinuz" admin@192.168.100.2:/tftpboot/fedora/
```
```powershell
scp "E:\images\pxeboot\initrd.img" admin@192.168.100.2:/tftpboot/fedora/
```

# Installationsdateien (ISO-Images) - HTTP vs NFS vs FTP

Die Trennung der Verzeichnisse hat folgende Gründe:

1. **/tftpboot**: 
   - Hier liegen die **Bootloader-Dateien** (für BIOS/EFI) und deren **Konfigurationsdateien**, sowie der **Kernel** (`vmlinuz`) und das **Initial RAM Disk Image** (`initrd.img`) für jede Distribution.
   - Dieses Verzeichnis dient ausschließlich dem **TFTP-Dienst**, der nur die grundlegenden Dateien bereitstellt, um den Bootprozess zu starten.

2. **ISO-Images separat per HTTP/NFS/FTP**:
   - Die vollständigen **Installationsdateien** der Distributionen (z. B. die ISO-Images) werden über Protokolle wie **HTTP, NFS oder FTP** bereitgestellt.
   - Diese Aufteilung ist effizienter, da der TFTP-Dienst für den schnellen und einfachen Zugriff auf Bootdateien ausgelegt ist, während größere Datenmengen besser über HTTP, NFS oder FTP übertragen werden.

Kurz gesagt: **/tftpboot** für die Startdateien, separate Protokolle für die vollständigen Installationsmedien.

```powershell
scp "C:\lab\vm\iso-images\CentOS-Stream-9-latest-x86_64-dvd1.iso" admin@192.168.100.2:/usr/local/www/iso
```
```powershell
scp "C:\lab\vm\iso-images\Fedora-Server-dvd-x86_64-41-1.4.iso" admin@192.168.100.2:/usr/local/www/iso
```
```powershell
ssh admin@192.168.100.2 ls -l /usr/local/www/iso
```
```powershell
PS C:\lab\vm\iso-images> ssh admin@192.168.100.2 ls -l /usr/local/www/iso
total 13521333
-rw-r--r--  1 root wheel 11322392576 Nov  4 08:36 CentOS-Stream-9-latest-x86_64-dvd1.iso
-rw-r--r--  1 root wheel  2818572288 Nov  4 08:34 Fedora-Server-dvd-x86_64-41-1.4.iso
PS C:\lab\vm\iso-images>
```

Im Web-Browser so abrufbar:
```plaintext
http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso
```
```plaintext
http://192.168.100.2/iso/Fedora-Server-dvd-x86_64-41-1.4.iso
```

# PXE Automatisierung durch Kickstart/Preseed/AutoInstall/Cloud-Init

## Kurze Übersicht:

1. **Kickstart**:
   - **Einsatzgebiet**: Red Hat-basierte Systeme (z.B. CentOS, Fedora).
   - **Funktion**: Automatisierte Installation über eine einfache Textdatei mit Konfigurationsanweisungen.
   - **Verwendung**: Häufig bei PXE-Installationen.

2. **Preseed**:
   - **Einsatzgebiet**: Debian-basierte Systeme (z.B. Debian, ältere Ubuntu-Versionen).
   - **Funktion**: Automatisierte Installation durch Antworten auf Installationsfragen in einer Textdatei.
   - **Verwendung**: Installation ohne Benutzerinteraktion.

3. **Autoinstall**:
   - **Einsatzgebiet**: Neue Ubuntu-Server-Versionen (ab 20.04).
   - **Funktion**: YAML-basierte Konfiguration für automatisierte Ubuntu-Installationen.
   - **Verwendung**: Ideal für moderne Ubuntu-Server-Installationen.

4. **Cloud-Init**:
   - **Einsatzgebiet**: Cloud-Umgebungen (z.B. AWS, Azure, OpenStack).
   - **Funktion**: Automatische Initialkonfiguration von Cloud-Instanzen nach der Bereitstellung.
   - **Verwendung**: Flexibel für nachträgliche Konfigurationsaufgaben.

## Kickstart Beispiel

Die Kickstart-Dateien für centos und fedora sind in dieser Repo unter `lab/vm/automation` zu finden.

`C:\lab\vm\automation\kickstart-centos.cfg`
`C:\lab\vm\automation\kickstart-fedora-server.cfg`

```powershell
ssh admin@192.168.100.2 mkdir -p /usr/local/www/automation
```
```powershell
scp "C:\lab\vm\automation\kickstart-centos.cfg" admin@192.168.100.2:/usr/local/www/automation
```
```powershell
scp "C:\lab\vm\automation\kickstart-fedora-server.cfg" admin@192.168.100.2:/usr/local/www/automation
```

Im Web-Browser so abrufbar:
```plaintext
http://192.168.100.2/automation/kickstart-centos.cfg
```
```plaintext
http://192.168.100.2/automation/kickstart-fedora-server.cfg
```

# BIOS /tftpboot/pxelinux.cfg/default Attributen setzen

```plaintext
DEFAULT menu.c32
PROMPT 0
TIMEOUT 600
ONTIMEOUT local

MENU TITLE PXE Boot Menu

LABEL local
  MENU LABEL Boot from local drive
  LOCALBOOT 0

LABEL Install CentOS
  MENU LABEL Install CentOS
  KERNEL /centos/vmlinuz
  APPEND initrd=/centos/initrd.img inst.repo=http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso inst.ks=http://192.168.100.2/automation/kickstart-centos.cfg

LABEL Install Fedora
  MENU LABEL Install Fedora
  KERNEL /fedora/vmlinuz
  APPEND initrd=/fedora/initrd.img inst.repo=http://192.168.100.2/iso/Fedora-Server-dvd-x86_64-41-1.4.iso inst.ks=http://192.168.100.2/automation/kickstart-fedora-server.cfg
```

# EFI /tftpboot/efi/boot/grub.cfg Attributen setzen

```plaintext
set default="0"
set timeout=60

function load_video {
  insmod efi_gop
  insmod efi_uga
  insmod video_bochs
  insmod video_cirrus
  insmod all_video
}

load_video
set gfxpayload=keep
insmod gzio
insmod part_gpt
insmod ext2

### Set the root to the HTTP server
search --no-floppy --set=root -l 'HTTP Server Root'

### Menu Entries
menuentry 'Install CentOS Stream 9' {
  linuxefi /centos/vmlinuz inst.repo=http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso inst.ks=http://192.168.100.2/automation/kickstart-centos.cfg quiet
  initrdefi /centos/initrd.img
}

menuentry 'Test this media & install CentOS Stream 9' {
  linuxefi /centos/vmlinuz inst.repo=http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso rd.live.check quiet
  initrdefi /centos/initrd.img
}

submenu 'Troubleshooting -->' {
  menuentry 'Install CentOS Stream 9 in text mode' {
    linuxefi /centos/vmlinuz inst.repo=http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso inst.text quiet
    initrdefi /centos/initrd.img
  }

  menuentry 'Rescue a CentOS Stream system' {
    linuxefi /centos/vmlinuz inst.repo=http://192.168.100.2/iso/CentOS-Stream-9-latest-x86_64-dvd1.iso inst.rescue quiet
    initrdefi /centos/initrd.img
  }
}
```

# pfSense Firewall Regeln setzen

```plaintext
webConfigurator http://192.168.100.2/
Firewall > Rules > LAN > Add
```

# TFTP port 69

* Edit Firewall Rule
  * Action: Pass
  * Interface: LAN
  * Address Family: IPv4
  * Protocol: UDP
* Source
  * Source: Any
  * Destination: This Firewall (self)
  * Destination Port Range: From: TFTP(69) To: TFTP(69)
* Extra Options
  * Description: Allow PXE TFTP to pfsense
* Save
* Apply Changes

# Abschließen

Um Ihre PXE-Einrichtung auf dem pfSense-Server abzuschließen, führen Sie folgende Schritte aus, um sicherzustellen, dass alles richtig konfiguriert und einsatzbereit ist:

### 1. **Überprüfen und Bestätigen der DHCP-Einstellungen auf pfSense**
   - Stellen Sie sicher, dass Ihre DHCP-Server-Einstellungen korrekt sind, um PXE-Optionen zu verteilen:
     - **TFTP-Server**: Setzen Sie dies auf `192.168.100.2` (die IP Ihres pfSense-Servers, wenn dieser als TFTP-Server fungiert).
     - **Netzwerk-Boot**:
       - **Next Server**: `192.168.100.2`
       - **Standard-BIOS-Dateiname**: `pxelinux.0`
       - **UEFI 64-Bit-Dateiname**: `efi/boot/grubx64.efi`
       - **UEFI HTTPBoot-URL**: Falls zutreffend, `http://192.168.100.2` für das HTTP-basierte Booten einrichten.

### 2. **Firewall-Regeln konfigurieren**
   - Stellen Sie sicher, dass die Firewall-Regeln von pfSense den Datenverkehr für das PXE-Booten zulassen:
     - **DHCP zulassen**: DHCP-Datenverkehr auf Ihrer LAN-Schnittstelle muss erlaubt sein.
     - **TFTP zulassen**: Öffnen Sie UDP-Port 69 für den TFTP-Datenverkehr.
     - **HTTP/FTP zulassen**: Wenn Sie HTTP verwenden, öffnen Sie Port 80 für den Web-Datenverkehr. Wenn Sie FTP verwenden, öffnen Sie Port 21.
     - **NFS zulassen**: Falls Sie NFS für die Installationsmedien verwenden, öffnen Sie die Ports 2049 (NFS), 111 (RPC) und eventuell erforderliche Mountd-Ports.

### 3. **TFTP-Konfiguration überprüfen**
   - Vergewissern Sie sich, dass der TFTP-Dienst auf pfSense aktiviert ist und `/tftpboot` als Stammverzeichnis verwendet wird.
   - Stellen Sie sicher, dass die `Leseberechtigungen` für `nobody` im TFTP-Verzeichnis und für alle darin enthaltenen Dateien korrekt gesetzt sind.

### 4. **HTTP/FTP/NFS-Dienste einrichten und testen**
   - **Für HTTP**:
     - Stellen Sie sicher, dass der integrierte Webserver von pfSense oder ein separater Webserver (z.B. nginx oder Apache auf einer eigenen VM) Ihre ISO-Images und Kickstart-Dateien korrekt bereitstellt.
     - Testen Sie den Zugriff auf die URLs in einem Webbrowser, um sicherzustellen, dass sie erreichbar sind.
   - **Für FTP**:
     - Wenn Sie FTP verwenden möchten, richten Sie einen FTP-Server auf pfSense oder einem separaten Rechner ein und testen Sie die Konnektivität.
   - **Für NFS**:
     - Überprüfen Sie, dass die NFS-Freigaben korrekt konfiguriert sind, falls Sie NFS für die Installationsmedien nutzen.

### 5. **PXE-Boot-Menü-Konfigurationen aktualisieren**
   - **BIOS-Konfiguration**: Überprüfen Sie `/tftpboot/pxelinux.cfg/default`, um sicherzustellen, dass alle Pfade korrekt sind.
   - **EFI-Konfiguration**: Überprüfen Sie `/tftpboot/efi/boot/grub.cfg`, um sicherzustellen, dass die Kernel- und Initrd-Images sowie die Installationsmedien richtig referenziert werden.

### 6. **PXE-Boot testen**
   - **Test mit einem BIOS-Client**: Versuchen Sie, einen VM- oder physischen Rechner im Legacy-BIOS-Modus zu booten, und stellen Sie sicher, dass das PXE-Menü erscheint und die Installationen starten.
   - **Test mit einem UEFI-Client**: Starten Sie einen UEFI-fähigen Rechner und prüfen Sie, ob der EFI-Bootloader geladen wird und der Installationsprozess startet.

### 7. **Fehlerbehebung**
   - **Protokolle prüfen**: Sehen Sie sich die DHCP-, TFTP- und HTTP-Protokolle auf pfSense und Ihren Servern an, um eventuelle Probleme zu diagnostizieren.
   - **Netzwerküberwachung**: Verwenden Sie Tools wie `tcpdump` auf pfSense, um den PXE-bezogenen Netzwerkverkehr zu überwachen und Probleme zu erkennen.

### 8. **Dokumentation und Backups**
   - Dokumentieren Sie Ihre Konfiguration, einschließlich IP-Adressen, Pfade und Konfigurationsdateien, für zukünftige Referenzen.
   - Erstellen Sie ein Backup Ihrer pfSense-Konfiguration und wichtiger Dateien aus Ihrer PXE-Einrichtung.

Sobald diese Schritte abgeschlossen sind, sollte Ihr PXE-Server vollständig einsatzbereit sein und Installationen der angegebenen Linux-Distributionen unterstützen.

# Backup

Die Sicherungen wurden in Github hier abgelegt: `lab/vm/backup/`

## Backup /tftpboot Struktur

Um ein Tar-Archiv des `/tftpboot`-Verzeichnisses auf pfSense zu erstellen und dabei die Unix-Berechtigungen, Zeitstempel und andere Attribute beizubehalten, können Sie den folgenden Befehl verwenden:

```sh
tar -cvpzf /root/tftpboot_backup.tar.gz /tftpboot
```

Erläuterung:
- `-c`: Erstellt ein neues Archiv.
- `-v`: Zeigt die verarbeiteten Dateien ausführlich an.
- `-p`: Beibehaltung der Berechtigungen.
- `-z`: Komprimiert das Archiv mit gzip.
- `-f`: Gibt den Dateinamen des Archivs an.

Stellen Sie sicher, dass Sie `/root/tftpboot_backup.tar.gz` durch den gewünschten Pfad und Namen für Ihr Backup-Archiv ersetzen.

Datei: `lab/vm/backup/tftpboot_backup.tar.gz`

## Restore /tftpboot Struktur

Um den Inhalt Ihres `/tftpboot`-Verzeichnisses aus dem Backup-Archiv `tftpboot_backup.tar.gz` wiederherzustellen, können Sie den folgenden `tar`-Befehl verwenden:

1. Wechseln Sie in das Stammverzeichnis (oder dorthin, wo `/tftpboot` wiederhergestellt werden soll):
   ```sh
   cd /
   ```

2. Extrahieren Sie den Inhalt des Backups und behalten Sie Berechtigungen und Zeitstempel bei:
   ```sh
   tar -xvpzf /root/tftpboot_backup.tar.gz
   ```

- **Erläuterung**:
  - `-x`: Dateien extrahieren.
  - `-v`: Ausführliche Ausgabe (zeigt die extrahierten Dateien an).
  - `-p`: Berechtigungen beibehalten.
  - `-z`: Archiv entpacken (falls es mit gzip komprimiert wurde).
  - `-f`: Gibt die Archivdatei an, die extrahiert werden soll.

Dieser Befehl stellt alle Dateien und Verzeichnisse in `/tftpboot` mit den ursprünglichen Berechtigungen und Zeitstempeln wieder her. Stellen Sie sicher, dass `/tftpboot` leer ist, bevor Sie den Befehl ausführen, um Konflikte zu vermeiden.

## Backup/Restore pfSense Einstellungen

```plaintext
webConfigurator http://192.168.100.2/
Diagnostics > Backup & Restore
```
* Backup Configuration
  * Download configuration as XML  <--- Backup
* Restore Backup
  * Configuration file: Choose file  <--- Restore

Datei: `lab/vm/backup/config-pfSense.home.arpa-20241104215607.xml`
