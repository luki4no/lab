# Inhaltsverzeichnis
- [Ansible Inventar-Liste ausfüllen](#ansible-inventar-liste-ausfüllen)
- [Namensauflösung auf allen VMs angleichen](#namensauflösung-auf-allen-vms-angleichen)
- [SSH Public Key verbreiten](#ssh-public-key-verbreiten)
- [Paketverwaltung - nano installieren/aktualisieren](#paketverwaltung---nano-installierenaktualisieren)
- [Dienstverwaltung](#dienstverwaltung)
- [Benutzer- und Gruppenverwaltung](#benutzer--und-gruppenverwaltung)
- [Datei- und Verzeichnisverwaltung](#datei--und-verzeichnisverwaltung)
- [Home-Verzeichnis verschlüsseln](#home-verzeichnis-verschlüsseln)
- [Sudo Timeout verlängern/verkürzen](#sudo-timeout-verlängernverkürzen)
- [Update und Upgrade (RedHat+Debian)](#update-und-upgrade-redhatdebian)
  - [Playbook für sudo apt/yum update](#playbook-für-sudo-aptyum-update)
  - [Playbook für sudo apt/yum upgrade](#playbook-für-sudo-aptyum-upgrade)
- [SSH Stärken (Hardening)](#ssh-stärken-hardening)
- [Netzwerkinfos abfragen](#netzwerkinfos-abfragen)
- [Docker installieren](#docker-installieren)
- [Git installieren](#git-installieren)
- [Top 3 Playbooks bezüglich Container](#top-3-playbooks-bezüglich-container)
- [Einrichtung von eCryptfs zur Verschlüsselung des Home-Verzeichnisses eines Benutzers](#einrichtung-von-ecryptfs-zur-verschlüsselung-des-home-verzeichnisses-eines-benutzers)
- [Durchsetzung des Minimalprinzips (Least Privilege)](#durchsetzung-des-minimalprinzips-least-privilege)
- [Sicherstellen, dass die Firewall aktiv ist](#sicherstellen-dass-die-firewall-aktiv-ist)
- [Passwortanforderungen festlegen](#passwortanforderungen-festlegen)
- [Festplatte verschlüsseln mit LUKS](#festplatte-verschlüsseln-mit-luks)
- [Wazuh Agent Deployment](#wazuh-agent-deployment)
- [Ansible Ad-Hoc Kommandos](#ansible-ad-hoc-kommandos)
  - [Ansible-Kommandos für die Verwaltung von Dateien, Berechtigungen, Verzeichnisse](#ansible-kommandos-für-die-verwaltung-von-dateien-berechtigungen-verzeichnisse)
  - [Debian - Deaktivieren des CD/DVD-Repositorys in Debian](#debian---deaktivieren-des-cddvd-repositorys-in-debian)


# Ansible Inventar-Liste ausfüllen

Dieses Playbook füllt die Datei `/etc/ansible/hosts` mit Einträgen für die Gruppen **[firewall]** und **[clients]**:

1. **Fügt eine Leerzeile** am Anfang der Datei hinzu.
2. **Erstellt die Gruppe `[firewall]`** mit einem Eintrag für `pfsense`.
3. **Erstellt die Gruppe `[clients]`** mit Einträgen für `centos`, `ubuntu`, `fedora`, `debian` und `kali`, jeweils mit Host-IP und Benutzername.

Leerzeilen zwischen den Einträgen sorgen für bessere Lesbarkeit.

```bash
sudo touch /etc/ansible/playbooks/populate-ansible-hosts.yml
```
```bash
sudo nano /etc/ansible/playbooks/populate-ansible-hosts.yml
```
```yml
---
- name: Populate /etc/ansible/hosts with firewall and clients
  hosts: localhost
  become: yes
  tasks:
    - name: Add initial blank line
      lineinfile:
        path: /etc/ansible/hosts
        line: ""
        state: present
        insertbefore: BOF

    - name: Add firewall group and pfSense host entry with spacing
      lineinfile:
        path: /etc/ansible/hosts
        line: "{{ item }}"
        state: present
      loop:
        - ""
        - "[firewall]"
        - "pfsense         ansible_host=192.168.100.2 ansible_user=admin"
        - ""

    - name: Add clients group and hosts entries with spacing
      lineinfile:
        path: /etc/ansible/hosts
        line: "{{ item }}"
        state: present
      loop:
        - ""
        - "[clients]"
        - "centos          ansible_host=192.168.100.10 ansible_user=lucian"
        - "ubuntu          ansible_host=192.168.100.11 ansible_user=lucian"
        - "fedora          ansible_host=192.168.100.12 ansible_user=lucian"
        - "debian          ansible_host=192.168.100.13 ansible_user=lucian"
        - "kali            ansible_host=192.168.100.14 ansible_user=lucian"
        - ""
```
```bash
ansible-playbook /etc/ansible/playbooks/populate-ansible-hosts.yml --ask-become-pass
```

# Namensauflösung auf allen VMs angleichen

Dieses Playbook aktualisiert die Datei `/etc/hosts` auf allen Hosts und stellt sicher, dass bestimmte Einträge vorhanden sind:

1. Fügt die IP-Adressen und zugehörigen Hostnamen für `pfsense`, `centos`, `ubuntu`, `fedora`, `debian` und `kali` hinzu.
2. Jeder Eintrag wird überprüft und nur hinzugefügt, wenn er noch nicht vorhanden ist. 

So wird sichergestellt, dass alle Hosts die gleichen `/etc/hosts`-Einträge haben.

```plaintext
192.168.100.2    pfsense
192.168.100.10   centos ansible docker greenbone wazuh onion
192.168.100.11   ubuntu ldap snort suricata ids ips
192.168.100.12   fedora
192.168.100.13   debian
192.168.100.14   kali
```

```bash
sudo touch /etc/ansible/playbooks/etc-hosts-sync.yml
```
```bash
sudo nano /etc/ansible/playbooks/etc-hosts-sync.yml
```
```yml
---
- name: Synchronize /etc/hosts across all clients
  hosts: clients
  become: yes
  vars:
    desired_hosts:
      - "192.168.100.2    pfsense"
      - "192.168.100.10   centos ansible docker greenbone wazuh onion"
      - "192.168.100.11   ubuntu ldap snort suricata ids ips"
      - "192.168.100.12   fedora"
      - "192.168.100.13   debian"
      - "192.168.100.14   kali"
      - "192.168.100.20   ws2016"
      - "192.168.100.21   w10"

  tasks:
    - name: Ensure /etc/hosts has only the specified entries
      copy:
        dest: /etc/hosts
        content: |
          127.0.0.1 localhost
          127.0.1.1 {{ inventory_hostname }}

          # BEGIN MANAGED HOSTS
          {% for host in desired_hosts %}
          {{ host }}
          {% endfor %}
        owner: root
        group: root
        mode: '0644'
```
```bash
ansible-playbook /etc/ansible/playbooks/etc-hosts-sync.yml --ask-become-pass
```

# SSH Public Key verbreiten

```bash
sudo touch /etc/ansible/playbooks/ssh-public-key-from-host.yml
```
```bash
sudo nano /etc/ansible/playbooks/ssh-public-key-from-host.yml
```

```yml
---
- name: Distribute public SSH key to all hosts
  hosts: all
  become: yes
  tasks:
    - name: Ensure .ssh directory exists
      file:
        path: ~/.ssh
        state: directory
        mode: '0700'

    - name: Add public key to authorized_keys
      authorized_key:
        user: "{{ ansible_user }}"
        state: present
        key: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQChU7+A3fep5sRkuJTcidAHMBlVqC5FsBoXwmscmkid+vIn1gW2T/+DhPtdOGA74CoiEV4H2Zn7zPecBLzrUre1wxsd0eMPdl02XLEO5z4GAdHU9IAXzYjV8Ftt/GCinE/dz3y3Vg3o1aNFWD7c5b6Fuh8oVE1v7K/N8Na1LimjdjJqhD0g6TGNQ/UilkofuXG/eftbowb8dfA3/4OUZ92zsTVlydC76GqudBCCcchI18DTVVqEhMK/UTiamgzV2lB2T6jM2rpYbP6np4V5yxtqDI8XV+WVnfqbsL/h7QlTxmiHA8VdMkazQ2iddUvxKxMbRk9FOUjrDmGtv8TtEx6lSOQ3XLpA65ljKOvncaEy3Wh9gpOy6Kpxcn3DH50QdhqY9py4OigZ3pqXqPwQTnEfyltDTbCweQ2Y42K/+hEIv0iqmmL6gtzPSemIyVzv+Z4ERJrPnn6kJiMsJgRUyVwCqVjkJV+VSWkjbEjPJmEv0CNP9aAtt6FCSQcXfkBK0Wmob5MkZzuO7kcHXs6GxvbbuugqSuHHzOP+jvVWSCsFATSw5TVDu4DzrP5sgGHJizByfjYQPGEL2cS+igWRykQV3mbdA3o6M/VVV2nmxn1ETZ6qeDm16QQU6ch9gf/YBLmxhStzgYlfIhuDoMsgyYa0Py9/xK0XHJDmPb3ddweqIQ== azuread\\lucianharalambie@LuciHP"
```
```bash
ansible-playbook /etc/ansible/playbooks/ssh-public-key-from-host.yml --ask-become-pass
```

# Paketverwaltung - nano installieren/aktualisieren

Dieses Playbook sorgt dafür, dass **nano** installiert und auf die neueste Version aktualisiert wird, sowohl auf Debian- als auch auf Red Hat-basierten Systemen.

## Erklärung von `state: latest`

- **`state: latest`** im `apt`- und `yum`-Modul stellt sicher, dass die **neueste verfügbare Version** des Pakets (hier `nano`) installiert wird.
- Wenn `nano` bereits installiert ist, aber nicht auf dem neuesten Stand, wird dieses Playbook es auf die neueste Version in den Paket-Repositories des Systems aktualisieren.

Das Ausführen dieses Playbooks installiert und aktualisiert **nano** auf die neueste Version auf allen Hosts in der Gruppe `clients`, abhängig vom jeweiligen Betriebssystem.

**Beispiel**: Installiere die neueste Version von `nano` auf allen Hosts.

```bash
sudo touch /etc/ansible/playbooks/nano-install-update.yml
```

```bash
sudo nano /etc/ansible/playbooks/nano-install-update.yml
```

```yaml
---
- name: Ensure nano is installed
  hosts: clients
  become: yes
  tasks:
    - name: Install nano on Debian-based systems
      apt:
        name: nano
        state: latest
      when: ansible_os_family == "Debian"

    - name: Install nano on RedHat-based systems
      yum:
        name: nano
        state: latest
      when: ansible_os_family == "RedHat"
```

```bash
ansible-playbook /etc/ansible/playbooks/nano-install-update.yml --ask-become-pass
```

# Dienstverwaltung

Dieses Playbook stellt sicher, dass der **SSH-Dienst (`sshd`) auf allen Hosts läuft und beim Systemstart aktiviert** ist.

### Funktionsweise:
1. **Hosts**: Es wird auf allen Hosts (`hosts: all`) ausgeführt.
2. **Berechtigungserhöhung**: `become: yes` sorgt dafür, dass der Befehl mit administrativen Rechten (sudo) ausgeführt wird.
3. **Task**:
   - Die Task verwendet das `service`-Modul, um sicherzustellen, dass der Dienst `sshd`:
     - **Gestartet** ist (`state: started`).
     - **Beim Systemstart automatisch aktiviert** ist (`enabled: yes`).

Das Playbook sorgt dafür, dass der SSH-Dienst immer verfügbar ist, um Verbindungen zu ermöglichen, und dass er beim Neustart des Systems automatisch startet.

```bash
sudo touch /etc/ansible/playbooks/ssh-service-running.yml
```
```bash
sudo nano /etc/ansible/playbooks/ssh-service-running.yml
```

```yaml
---
- name: Ensure SSH service is running
  hosts: all
  become: yes
  tasks:
    - name: Ensure sshd is running and enabled
      service:
        name: sshd
        state: started
        enabled: yes
```
```bash
ansible-playbook /etc/ansible/playbooks/ssh-service-running.yml --ask-become-pass
```

# Benutzer- und Gruppenverwaltung

**Benutzer und Gruppen erstellen, löschen oder ändern**.
**Beispiel**: Erstellen Sie einen Benutzer namens `devuser` mit sudo-Berechtigungen.

```bash
sudo touch /etc/ansible/playbooks/user-add-sudo-add.yml
```
```bash
sudo nano /etc/ansible/playbooks/user-add-sudo-add.yml
```

```yaml
---
- name: Create a new user with sudo privileges
  hosts: all
  become: yes
  tasks:
    - name: Add devuser to the system
      user:
        name: devuser
        state: present
        shell: /bin/bash
        create_home: yes  # Sicherstellt, dass das Home-Verzeichnis erstellt wird

    - name: Add devuser to the sudo group
      user:
        name: devuser
        groups: sudo
        append: yes
```
```bash
ansible-playbook user-add-sudo-add.yml --ask-become-pass
```

# Datei- und Verzeichnisverwaltung

- **Dateien kopieren, Berechtigungen verwalten, Verzeichnisse erstellen und mehr**.
- **Beispiel**: Eine Konfigurationsdatei auf alle Hosts kopieren.

```bash
sudo touch /etc/ansible/playbooks/copy-config-file.yml
```
```bash
sudo nano /etc/ansible/playbooks/copy-config-file.yml
```
```yaml
---
- name: Copy custom configuration file
  hosts: clients
  become: yes
  tasks:
    - name: Copy /etc/myapp.conf to all hosts
      copy:
        src: /home/user/myapp.conf
        dest: /etc/myapp.conf
        owner: root
        group: root
        mode: '0644'
```
```bash
ansible-playbook copy-config-file.yml --ask-become-pass
```

# Home-Verzeichnis verschlüsseln

```bash
sudo touch /etc/ansible/playbooks/home-dir-encryption.yml
```
```bash
sudo nano /etc/ansible/playbooks/home-dir-encryption.yml
```
```yaml
- name: Setup eCryptfs for user home directory encryption
  hosts: clients
  become: true
  tasks:
    # Install eCryptfs utilities
    - name: Install eCryptfs utilities
      package:
        name: ecryptfs-utils
        state: present
      when: ansible_os_family in ["Debian", "RedHat"]

    # Ensure the user exists
    - name: Ensure user 'lucian' exists
      user:
        name: lucian
        state: present

    # Encrypt the user's home directory
    - name: Enable encryption for user 'lucian'
      command: ecryptfs-setup-private
      args:
        creates: /home/lucian/.Private
      environment:
        HOME: /home/lucian
      when: ansible_os_family in ["Debian", "RedHat"]

    # Mount the encrypted home directory
    - name: Mount encrypted home directory
      shell: |
        ecryptfs-mount-private
      environment:
        HOME: /home/lucian
      when: ansible_os_family in ["Debian", "RedHat"]

    # Add the encrypted mount to /etc/fstab
    - name: Add encrypted mount to fstab
      lineinfile:
        path: /etc/fstab
        line: "/home/lucian/.Private /home/lucian ecryptfs defaults 0 0"
        state: present
      when: ansible_os_family in ["Debian", "RedHat"]

```
```bash
ansible-playbook /etc/ansible/playbooks/home-dir-encryption.yml --ask-become-pass
```

# Sudo Timeout verlängern/verkürzen

Die Zeile `timestamp_timeout = 60` in `visudo` legt fest, dass **sudo-Rechte für 60 Minuten** nach einer erfolgreichen Passworteingabe gespeichert werden. Innerhalb dieser Zeit muss das Passwort für weitere `sudo`-Befehle nicht erneut eingegeben werden.

```bash
sudo touch /etc/ansible/playbooks/sudo-timeout.yml
```
```bash
sudo nano /etc/ansible/playbooks/sudo-timeout.yml
```
```yml
---
- name: Set sudo timeout to 1 hour on all hosts
  hosts: clients
  become: yes
  tasks:
    - name: Ensure sudoers file has timestamp_timeout set to 60 minutes
      lineinfile:
        path: /etc/sudoers
        regexp: '^Defaults\s+timestamp_timeout='
        line: 'Defaults timestamp_timeout=60'
        state: present
        validate: '/usr/sbin/visudo -cf %s'
```
```bash
ansible-playbook /etc/ansible/playbooks/sudo-timeout.yml --ask-become-pass
```

# Update und Upgrade (RedHat+Debian)

## Playbook für `sudo apt/yum update`
Dieses Playbook führt ein **Update der Paketlisten** durch, aber **aktualisiert noch keine Pakete**.

- **Debian**: Führt `apt update` aus, um die Paketlisten zu aktualisieren.
- **Red Hat**: Führt `yum makecache` aus, was einem `yum update` der Paketlisten entspricht.

```bash
sudo touch /etc/ansible/playbooks/apt-yum-update.yml
```
```bash
sudo nano /etc/ansible/playbooks/apt-yum-update.yml
```
```yaml
---
- name: Update package lists
  hosts: clients
  become: yes
  tasks:
    - name: Update package lists on Debian-based systems
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Update package lists on Red Hat-based systems
      yum:
        name: '*'
        state: latest
        update_cache: yes
      when: ansible_os_family == "RedHat"
```
```bash
ansible-playbook /etc/ansible/playbooks/apt-yum-update.yml --ask-become-pass
```

## Playbook für `sudo apt/yum upgrade`
Dieses Playbook führt ein **Upgrade der Pakete** durch, um installierte Pakete auf die neuesten Versionen zu aktualisieren.

- **Debian**: Führt `apt upgrade` (in diesem Fall `dist-upgrade`) aus, um alle Pakete zu aktualisieren.
- **Red Hat**: Führt `yum update` für alle Pakete aus, sodass alle Pakete auf die neueste Version gebracht werden.

```bash
sudo touch /etc/ansible/playbooks/apt-yum-upgrade.yml
```
```bash
sudo nano /etc/ansible/playbooks/apt-yum-upgrade.yml
```

```yaml
---
- name: Upgrade packages to the latest version
  hosts: clients
  become: yes
  tasks:
    - name: Upgrade packages on Debian-based systems
      apt:
        upgrade: dist
      when: ansible_os_family == "Debian"

    - name: Upgrade packages on Red Hat-based systems
      yum:
        name: '*'
        state: latest
      when: ansible_os_family == "RedHat"
```
```bash
ansible-playbook /etc/ansible/playbooks/apt-yum-upgrade.yml --ask-become-pass
```

### Zusammenfassung
Mit diesen beiden Playbooks können Sie:
- Zuerst die **Paketlisten aktualisieren** (`update`).
- Danach ein **Upgrade der Pakete** (`upgrade`) durchführen, um die neuesten Versionen zu installieren. 

Diese Struktur sorgt für mehr Kontrolle über den Aktualisierungsprozess.

# SSH Stärken (Hardening)

Dieses Playbook funktioniert sowohl auf **Debian-** als auch auf **Red Hat-basierten Systemen**, da die Konfiguration von SSH in der Datei `/etc/ssh/sshd_config` in beiden Distributionen identisch ist. 

```bash
sudo touch /etc/ansible/playbooks/ssh-hardening.yml
```
```bash
sudo nano /etc/ansible/playbooks/ssh-hardening.yml
```

```yaml
---
- name: Harden SSH settings
  hosts: clients
  become: yes
  tasks:
    - name: Disable root login and enable key-based authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^PermitRootLogin'
        line: 'PermitRootLogin no'
      notify:
        - Restart SSH

    - name: Ensure PubkeyAuthentication is enabled
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#PubkeyAuthentication yes'
        line: 'PubkeyAuthentication yes'
      notify:
        - Restart SSH

    - name: Disable password authentication
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#PasswordAuthentication yes'
        line: 'PasswordAuthentication no'
      notify:
        - Restart SSH

    - name: Set SSH protocol to version 2
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#Protocol'
        line: 'Protocol 2'
      notify:
        - Restart SSH

    - name: Disable empty passwords
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#PermitEmptyPasswords'
        line: 'PermitEmptyPasswords no'
      notify:
        - Restart SSH

    - name: Limit SSH access to specific users
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#AllowUsers'
        line: 'AllowUsers your_username'  # Replace 'your_username' with the desired username
      notify:
        - Restart SSH

    - name: Restrict SSH access to specific IP address range
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#AllowUsers.*'
        line: 'AllowUsers your_username@192.168.100.0/24'  # Replace 'your_username' with the desired username
        state: present
      notify:
        - Restart SSH

  handlers:
    - name: Restart SSH
      service:
        name: sshd
        state: restarted
```
```bash
ansible-playbook /etc/ansible/playbooks/ssh-hardening.yml --ask-become-pass
```

# Netzwerkinfos abfragen

Dieses Playbook sammelt Netzwerkinformationen von Hosts in der Gruppe **`clients`** und zeigt sie an. 

## Aufgaben:
1. **IP-Adressen abrufen**: Führt `ip addr show` aus und speichert die Informationen in `ip_info`.
2. **IP-Adressen anzeigen**: Nutzt das `debug`-Modul, um die IP-Adressen anzuzeigen.
3. **Routing-Tabelle abrufen**: Führt `ip route show` aus und speichert die Informationen in `route_info`.
4. **Routing-Tabelle anzeigen**: Zeigt die Routing-Tabelleninformationen an.
5. **DNS-Informationen abrufen**: Liest die Datei `/etc/resolv.conf` und speichert die Daten in `dns_info`.
6. **DNS-Informationen anzeigen**: Zeigt die gesammelten DNS-Informationen an.

## Ergebnis:
Das Playbook liefert eine Übersicht über die IP-Adressen, Routing-Tabellen und DNS-Serverinformationen der Hosts in der Gruppe `clients`.

```bash
sudo touch /etc/ansible/playbooks/network-info.yml
```
```bash
sudo nano /etc/ansible/playbooks/network-info.yml
```
```yml
---
- name: Gather network settings
  hosts: clients
  become: yes
  tasks:
    - name: Gather IP address information
      command: ip addr show
      register: ip_info

    - name: Display IP address information
      debug:
        var: ip_info.stdout_lines

    - name: Gather routing table information
      command: ip route show
      register: route_info

    - name: Display routing table information
      debug:
        var: route_info.stdout_lines

    - name: Gather DNS information
      command: cat /etc/resolv.conf
      register: dns_info

    - name: Display DNS information
      debug:
        var: dns_info.stdout_lines
```
```bash
ansible-playbook /etc/ansible/playbooks/network-info.yml --ask-become-pass
```

Sie können auch Ansible-Ad-hoc-Befehle verwenden, um Netzwerkinformationen direkt für einen bestimmten Host auszuführen. Hier sind einige Beispiele, wie Sie die entsprechenden Befehle für einen spezifischen Host anpassen können.

## Beispielbefehle

1. **IP-Adresse abrufen**:
   ```bash
   ansible <hostname> -m command -a "ip addr show" --become --ask-become-pass
   ```

2. **Routing-Tabelle abrufen**:
   ```bash
   ansible <hostname> -m command -a "ip route show" --become --ask-become-pass
   ```

3. **DNS-Informationen abrufen**:
   ```bash
   ansible <hostname> -m command -a "cat /etc/resolv.conf" --become --ask-become-pass
   ```

## Erklärung:
- Ersetzen Sie `<hostname>` durch den Namen oder die IP-Adresse des spezifischen Hosts, den Sie abfragen möchten.
- **`-m command`**: Dies gibt an, dass das `command`-Modul verwendet wird, um den angegebenen Befehl auszuführen.
- **`--become` und `--ask-become-pass`**: Diese Optionen ermöglichen es Ihnen, den Befehl mit erhöhten Rechten (z. B. als root) auszuführen und fordern nach dem `sudo`-Passwort.

## Beispiel:
Um die IP-Adresse für einen Host mit dem Namen `debian` abzurufen, würde der Befehl so aussehen:

```bash
ansible debian -m command -a "ip addr show"
```

Diese Ad-hoc-Befehle sind eine einfache und effektive Möglichkeit, um spezifische Informationen von einzelnen Hosts abzurufen, ohne ein vollständiges Playbook zu schreiben.

# Docker installieren

```bash
sudo touch /etc/ansible/playbooks/docker-install.yml
```
```bash
sudo nano /etc/ansible/playbooks/docker-install.yml
```
```yaml
---
- name: Install Docker on Debian, Ubuntu, CentOS, and Fedora
  hosts: clients
  become: yes

  tasks:
    # Uninstall conflicting packages for all distributions
    - name: Remove conflicting packages
      block:
        - name: Remove conflicting packages on Debian/Ubuntu
          ansible.builtin.shell: |
            for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do
              apt remove -y $pkg
            done
          when: ansible_os_family == "Debian"

        - name: Remove conflicting packages on CentOS/Fedora
          ansible.builtin.shell: |
            dnf remove -y docker docker-client docker-client-latest docker-common \
              docker-latest docker-latest-logrotate docker-logrotate docker-selinux \
              docker-engine-selinux docker-engine
          when: ansible_os_family == "RedHat"

    # Debian-based systems
    - name: Install Docker on Debian-based systems
      block:
        - name: Add Docker GPG key and repository
          ansible.builtin.shell: |
            install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/{{ ansible_distribution | lower }}/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            chmod a+r /etc/apt/keyrings/docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/{{ ansible_distribution | lower }} $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
          args:
            creates: /etc/apt/keyrings/docker.gpg

        - name: Update apt cache
          ansible.builtin.apt:
            update_cache: yes

        - name: Install Docker packages
          ansible.builtin.apt:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-compose-plugin
            state: present
      when: ansible_os_family == "Debian"

    # Red Hat-based systems
    - name: Install Docker on Red Hat-based systems
      block:
        - name: Install dnf-plugins-core
          ansible.builtin.dnf:
            name: dnf-plugins-core
            state: present

        - name: Add Docker repository
          ansible.builtin.shell: |
            dnf config-manager --add-repo https://download.docker.com/linux/{{ ansible_distribution | lower }}/docker-ce.repo
          args:
            creates: /etc/yum.repos.d/docker-ce.repo

        - name: Install Docker packages
          ansible.builtin.dnf:
            name:
              - docker-ce
              - docker-ce-cli
              - containerd.io
              - docker-compose-plugin
            state: present
            update_cache: yes
      when: ansible_os_family == "RedHat"

    # Start Docker service for all systems
    - name: Enable and start Docker service
      ansible.builtin.systemd:
        name: docker
        enabled: yes
        state: started

    # Add user 'lucian' to the Docker group
    - name: Add user to Docker group
      ansible.builtin.user:
        name: lucian
        groups: docker
        append: yes
```
Auf allen clients:
```bash
ansible-playbook /etc/ansible/playbooks/docker-install.yml --ask-become-pass
```
Auf bestimmten Maschinen:
```bash
ansible-playbook /etc/ansible/playbooks/docker-install.yml --limit "ubuntu,fedora" --ask-become-pass
```

# Git installieren

```bash
sudo touch /etc/ansible/playbooks/git-install.yml
```
```bash
sudo nano /etc/ansible/playbooks/git-install.yml
```
```yaml
---
- name: Install Git on target hosts
  hosts: clients
  become: true
  tasks:
    - name: Install Git on Red Hat-based systems
      ansible.builtin.yum:
        name: git
        state: present
      when: ansible_os_family == "RedHat"

    - name: Install Git on Debian-based systems
      ansible.builtin.apt:
        name: git
        state: present
        update_cache: yes
      when: ansible_os_family == "Debian"
```
Auf allen clients:
```bash
ansible-playbook /etc/ansible/playbooks/git-install.yml --ask-become-pass
```
Auf bestimmten Maschinen:
```bash
ansible-playbook /etc/ansible/playbooks/git-install.yml --limit "ubuntu,fedora" --ask-become-pass
```

# Top 3 Playbooks bezüglich Container

## 1. Docker Installation Playbook

Dieses Playbook installiert Docker auf den Ziel-Hosts.

```yaml
---
- name: Install Docker
  hosts: all
  become: yes
  tasks:
    - name: Install required packages
      apt:
        name: "{{ item }}"
        state: present
      loop:
        - apt-transport-https
        - ca-certificates
        - curl
        - software-properties-common

    - name: Add Docker GPG key
      apt_key:
        url: "https://download.docker.com/linux/ubuntu/gpg"
        state: present

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        state: present

    - name: Install Docker
      apt:
        name: docker-ce
        state: latest

    - name: Ensure Docker is running
      service:
        name: docker
        state: started
        enabled: yes
```

## 2. Docker Container Management Playbook

Dieses Playbook erstellt und verwaltet Docker-Container.

```yaml
---
- name: Manage Docker containers
  hosts: all
  become: yes
  tasks:
    - name: Ensure a Docker container is running
      docker_container:
        name: my_container
        image: nginx:latest
        state: started
        restart_policy: always
        ports:
          - "80:80"
```

## 3. Kubernetes Installation und Bereitstellung

Dieses Playbook installiert Kubernetes und erstellt ein einfaches Deployment.

```yaml
---
- name: Install Kubernetes
  hosts: all
  become: yes
  tasks:
    - name: Install prerequisites
      apt:
        name: "{{ item }}"
        state: present
      loop:
        - apt-transport-https
        - ca-certificates
        - curl
        - software-properties-common

    - name: Add Kubernetes GPG key
      apt_key:
        url: "https://packages.cloud.google.com/apt/doc/apt-key.gpg"
        state: present

    - name: Add Kubernetes repository
      apt_repository:
        repo: "deb https://apt.kubernetes.io/ kubernetes-xenial main"
        state: present

    - name: Install Kubernetes components
      apt:
        name: "{{ item }}"
        state: latest
      loop:
        - kubelet
        - kubeadm
        - kubectl

    - name: Initialize Kubernetes cluster
      command: kubeadm init
      register: kubeadm_init
      when: inventory_hostname == groups['all'][0]

    - name: Set up local kubeconfig
      command: "{{ item }}"
      with_items:
        - "mkdir -p $HOME/.kube"
        - "sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config"
        - "sudo chown $(id -u):$(id -g) $HOME/.kube/config"
      when: inventory_hostname == groups['all'][0]

    - name: Deploy a simple nginx application
      kubernetes.core.k8s:
        namespace: default
        name: nginx
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: nginx
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: nginx
            template:
              metadata:
                labels:
                  app: nginx
              spec:
                containers:
                  - name: nginx
                    image: nginx:latest
                    ports:
                      - containerPort: 80
```

Diese Playbooks helfen bei der Installation und Verwaltung von Docker und Kubernetes sowie bei der Bereitstellung von Containern.

# Einrichtung von eCryptfs zur Verschlüsselung des Home-Verzeichnisses eines Benutzers

```bash
sudo touch /etc/ansible/playbooks/eCryptfs-home.yml
```
```bash
sudo nano /etc/ansible/playbooks/eCryptfs-home.yml
```
```yaml
- name: Setup eCryptfs for user home directory encryption
  hosts: clients
  become: true
  tasks:
    # Install eCryptfs utilities
    - name: Install eCryptfs utilities
      package:
        name: ecryptfs-utils
        state: present
      when: ansible_os_family in ["Debian", "RedHat"]

    # Ensure the user exists
    - name: Ensure user 'lucian' exists
      user:
        name: lucian
        state: present

    # Encrypt the user's home directory
    - name: Enable encryption for user 'lucian'
      command: ecryptfs-setup-private
      args:
        creates: /home/lucian/.Private
      environment:
        HOME: /home/lucian
      when: ansible_os_family in ["Debian", "RedHat"]

    # Mount the encrypted home directory
    - name: Mount encrypted home directory
      shell: |
        ecryptfs-mount-private
      environment:
        HOME: /home/lucian
      when: ansible_os_family in ["Debian", "RedHat"]

    # Add the encrypted mount to /etc/fstab
    - name: Add encrypted mount to fstab
      lineinfile:
        path: /etc/fstab
        line: "/home/lucian/.Private /home/lucian ecryptfs defaults 0 0"
        state: present
      when: ansible_os_family in ["Debian", "RedHat"]
```
```bash
ansible-playbook /etc/ansible/playbooks/eCryptfs-home.yml --ask-become-pass
```

# Durchsetzung des Minimalprinzips (Least Privilege)

```bash
sudo touch /etc/ansible/playbooks/enforce-least-privilege.yml
```
```bash
sudo nano /etc/ansible/playbooks/enforce-least-privilege.yml
```
```yml
- name: Enforce Least Privilege
  hosts: clients
  tasks:
    - name: Create a limited user group
      group:
        name: limited
        state: present

    - name: Add user to limited group
      user:
        name: lucian
        groups: limited
        append: yes
```
```bash
ansible-playbook /etc/ansible/playbooks/enforce-least-privilege.yml --ask-become-pass
```

# Sicherstellen, dass die Firewall aktiv ist

```bash
sudo touch /etc/ansible/playbooks/firewall-active.yml
```
```bash
sudo nano /etc/ansible/playbooks/firewall-active.yml
```
```yml
- name: Configuration Enforcement
  hosts: clients
  tasks:
    - name: Ensure Firewall is running (Debian-based systems)
      service:
        name: ufw
        state: started
        enabled: yes
      when: ansible_os_family == "Debian"

    - name: Ensure Firewall is running (Red Hat-based systems)
      service:
        name: firewalld
        state: started
        enabled: yes
      when: ansible_os_family == "RedHat"

    - name: Verify certificate status
      command: openssl verify /path/to/certificate.pem
```
```bash
ansible-playbook /etc/ansible/playbooks/firewall-active.yml --ask-become-pass
```

# Passwortanforderungen festlegen

```bash
sudo touch /etc/ansible/playbooks/password-requirements.yml
```
```bash
sudo nano /etc/ansible/playbooks/password-requirements.yml
```
```yaml
---
- name: Secure user accounts
  hosts: clients
  become: true
  tasks:
    - name: Set minimum password length
      lineinfile:
        path: /etc/security/pwquality.conf
        regexp: '^minlen'
        line: 'minlen = 8'
        state: present
      when: ansible_os_family in ["RedHat", "Debian"]

    - name: Set password complexity requirements
      blockinfile:
        path: /etc/security/pwquality.conf
        block: |
          minclass = 3
          maxrepeat = 2
          maxsequence = 3
      when: ansible_os_family in ["RedHat", "Debian"]

    - name: Enforce password expiration policy
      lineinfile:
        path: /etc/login.defs
        regexp: '^PASS_MAX_DAYS'
        line: 'PASS_MAX_DAYS 90'
        state: present
      when: ansible_os_family in ["RedHat", "Debian"]

    - name: Add restrictions to user accounts
      user:
        name: testuser
        password_lock: yes
        shell: /sbin/nologin
      when: ansible_os_family in ["RedHat", "Debian"]
```
```bash
ansible-playbook /etc/ansible/playbooks/password-requirements.yml --ask-become-pass
```

# Festplatte verschlüsseln mit LUKS

Centos Beispiel:
```bash
sudo touch /etc/ansible/playbooks/centos-luks-encryption.yml
```
```bash
sudo nano /etc/ansible/playbooks/centos-luks-encryption.yml
```
```yaml
- name: Convert CentOS to LUKS-encrypted setup
  hosts: centos
  become: true
  tasks:
    # Backup Notice
    - name: Backup notice
      debug:
        msg: "Ensure you have a full backup before proceeding. This playbook will format and encrypt root and swap volumes."

    # Install required tools
    - name: Install cryptsetup for LUKS
      yum:
        name: cryptsetup
        state: present

    # Unmount filesystems
    - name: Unmount root filesystem
      command: umount /dev/mapper/VolGroup-root
      ignore_errors: yes

    - name: Unmount swap partition
      command: swapoff /dev/mapper/VolGroup-swap
      ignore_errors: yes

    # Close LVM volumes
    - name: Deactivate LVM volume group
      command: vgchange -an VolGroup

    # Encrypt logical volumes with LUKS
    - name: Encrypt root volume with LUKS
      command: cryptsetup luksFormat /dev/VolGroup/root --batch-mode --cipher aes-xts-plain64 --key-size 512 --hash sha256

    - name: Encrypt swap volume with LUKS
      command: cryptsetup luksFormat /dev/VolGroup/swap --batch-mode --cipher aes-xts-plain64 --key-size 512 --hash sha256

    # Open encrypted volumes
    - name: Open encrypted root volume
      command: cryptsetup luksOpen /dev/VolGroup/root luks-root

    - name: Open encrypted swap volume
      command: cryptsetup luksOpen /dev/VolGroup/swap luks-swap

    # Format encrypted volumes
    - name: Format encrypted root volume with xfs
      filesystem:
        fstype: xfs
        dev: /dev/mapper/luks-root

    - name: Format encrypted swap volume
      command: mkswap /dev/mapper/luks-swap

    # Update fstab and crypttab for encrypted volumes
    - name: Add encrypted root volume to crypttab
      lineinfile:
        path: /etc/crypttab
        line: "luks-root /dev/VolGroup/root none luks"
        state: present

    - name: Add encrypted swap volume to crypttab
      lineinfile:
        path: /etc/crypttab
        line: "luks-swap /dev/VolGroup/swap none luks"
        state: present

    - name: Update fstab for encrypted root volume
      lineinfile:
        path: /etc/fstab
        line: "/dev/mapper/luks-root / xfs defaults 0 1"
        state: present

    - name: Update fstab for encrypted swap volume
      lineinfile:
        path: /etc/fstab
        line: "/dev/mapper/luks-swap swap swap defaults 0 0"
        state: present

    # Reactivate and mount encrypted volumes
    - name: Mount encrypted root volume
      mount:
        path: /
        src: /dev/mapper/luks-root
        fstype: xfs
        state: mounted

    - name: Enable encrypted swap volume
      command: swapon /dev/mapper/luks-swap

    # Rebuild initramfs to include LUKS configuration
    - name: Rebuild initramfs
      command: dracut -f

    # Update GRUB to include LUKS configuration
    - name: Update GRUB configuration
      command: grub2-mkconfig -o /boot/grub2/grub.cfg
```
```bash
ansible-playbook /etc/ansible/playbooks/centos-luks-encryption.yml --ask-become-pass
```

# Wazuh Agent Deployment

```bash
sudo touch /etc/ansible/playbooks/deploy_wazuh_agent.yml
```
```bash
sudo nano /etc/ansible/playbooks/deploy_wazuh_agent.yml
```
```yaml
---
- name: Deploy Wazuh Agent on all clients
  hosts: clients
  become: true
  tasks:

    - name: Install required dependencies (CentOS/Fedora)
      when: ansible_os_family == "RedHat"
      package:
        name:
          - curl
          - gnupg
          - ca-certificates
        state: present

    - name: Install required dependencies (Debian/Ubuntu/Kali)
      when: ansible_os_family == "Debian"
      package:
        name:
          - curl
          - gnupg
          - ca-certificates
        state: present

    - name: Add Wazuh repository (CentOS/Fedora)
      when: ansible_os_family == "RedHat"
      shell: |
        rpm --import https://packages.wazuh.com/key/GPG-KEY-WAZUH
        curl -s -o /etc/yum.repos.d/wazuh.repo https://packages.wazuh.com/yum/el/7/wazuh.repo

    - name: Add Wazuh repository (Debian/Ubuntu/Kali)
      when: ansible_os_family == "Debian"
      shell: |
        curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add -
        echo "deb https://packages.wazuh.com/apt stable main" > /etc/apt/sources.list.d/wazuh.list
        apt-get update

    - name: Install Wazuh Agent
      package:
        name: wazuh-agent
        state: present

    - name: Configure Wazuh Agent
      lineinfile:
        path: /var/ossec/etc/ossec.conf
        regexp: '<address>.*</address>'
        line: '<address>192.168.100.10</address>'
        state: present

    - name: Register Agent with Wazuh Manager
      shell: /var/ossec/bin/agent-auth -m 192.168.100.10

    - name: Enable and Start Wazuh Agent
      service:
        name: wazuh-agent
        state: started
        enabled: true
```
```bash
ansible-playbook /etc/ansible/playbooks/deploy_wazuh_agent.yml --ask-become-pass
```

# Ansible Ad-Hoc Kommandos

## Ansible-Kommandos für die Verwaltung von Dateien, Berechtigungen, Verzeichnisse

1) **Datei auf allen Clients kopieren**:
   ```bash
   ansible clients -m copy -a "src=/pfad/zur/datei dest=/ziel/pfad/zur/datei"
   ```

2) **Berechtigungen verwalten**:
   ```bash
   ansible clients -m file -a "path=/pfad/zur/datei owner=benutzer group=gruppe mode=0755"
   ```

3) **Verzeichnis erstellen**:
   ```bash
   ansible clients -m file -a "path=/pfad/zum/verzeichnis state=directory mode=0755"
   ```

### Erklärung
- **clients**: Die Gruppe der Hosts, auf denen die Befehle ausgeführt werden.
- **`copy`-Modul**: Wird verwendet, um Dateien zu kopieren.
- **`file`-Modul**: Ermöglicht das Festlegen von Besitzer, Gruppe, Berechtigungen und die Erstellung von Verzeichnissen.
- **`state=directory`**: Gibt an, dass ein Verzeichnis erstellt werden soll.

Diese Kommandos führen die genannten Aufgaben auf allen Hosts in der Gruppe `clients` aus.

## Debian - Deaktivieren des CD/DVD-Repositorys in Debian

Ansible Fehler:

`fatal: [debian]: FAILED! => {"changed": false, "msg": "Failed to update apt cache: W:Updating from such a repository can't be done securely, and is therefore disabled by default., W:See apt-secure(8) manpage for repository creation and user configuration details., E:The repository 'cdrom://[Debian GNU/Linux 12.7.0 _Bookworm_ - Official amd64 DVD Binary-1 with firmware 20240831-10:40] bookworm Release' does not have a Release file."}`

Der Fehler tritt auf, weil Debian versucht, ein **Repository von der CD/DVD** (lokales Installationsmedium) zu aktualisieren, das als Quelle in der **Apt-Konfiguration** eingetragen ist. Dieses Repository ist jedoch nicht sicher und kann nicht automatisch aktualisiert werden.

Um das Problem zu beheben, können Sie die CD/DVD-Quelle in der Datei **`/etc/apt/sources.list`** deaktivieren.

1. **Bearbeiten der Datei `/etc/apt/sources.list` auf dem Debian-Host**:
   - Öffnen Sie die Datei `/etc/apt/sources.list`.
   - Kommentieren Sie die Zeilen aus, die mit `cdrom:` beginnen, indem Sie ein `#` vor die Zeile setzen.
   
   Beispiel:
   ```plaintext
   # deb cdrom:[Debian GNU/Linux 12.7.0 _Bookworm_ - Official amd64 DVD Binary-1 with firmware 20240831-10:40] bookworm Release
   ```

2. **Ansible Playbook zur Automatisierung** (optional):
   Falls Sie diesen Schritt auf mehreren Debian-Hosts automatisieren möchten, können Sie ein kleines Ansible-Playbook verwenden:

   ```yaml
   ---
   - name: Disable CD/DVD repository on Debian systems
     hosts: debian_hosts
     become: yes
     tasks:
       - name: Comment out cdrom entry in sources.list
         lineinfile:
           path: /etc/apt/sources.list
           regexp: '^deb cdrom:'
           line: '# deb cdrom:'
           state: present
   ```

3. **Apt-Cache erneut aktualisieren**:
   Nachdem die CD/DVD-Quelle deaktiviert wurde, können Sie das ursprüngliche `update`-Playbook erneut ausführen. Jetzt sollte die Aktualisierung erfolgreich durchgeführt werden.

Durch das Deaktivieren des CD/DVD-Repositorys wird der Fehler behoben, und Debian verwendet nur Online-Quellen für Updates.

Sie können das auch direkt mit einem **Ansible-Ad-hoc-Kommando** erledigen, ohne ein Playbook zu schreiben. Verwenden Sie das `lineinfile`-Modul, um die CD/DVD-Quelle in der Datei `/etc/apt/sources.list` auf Ihrem Debian-Host auszukommentieren.

Hier ist das Ansible-Kommando:

```bash
ansible debian -m lineinfile -a "path=/etc/apt/sources.list regexp='^deb cdrom:' line='# deb cdrom:' state=present" --become --ask-become-pass
```

### Erklärung:
- **`debian`**: Die Host-Gruppe, auf der das Kommando ausgeführt wird. Falls Sie eine andere Gruppe oder einen spezifischen Host haben, passen Sie den Namen entsprechend an.
- **`-m lineinfile`**: Verwendet das `lineinfile`-Modul.
- **`path=/etc/apt/sources.list`**: Zielt auf die Datei `/etc/apt/sources.list`.
- **`regexp='^deb cdrom:'`**: Sucht nach Zeilen, die mit `deb cdrom:` beginnen.
- **`line='# deb cdrom:'`**: Kommentiert diese Zeilen aus, indem ein `#` davor gesetzt wird.
- **`state=present`**: Stellt sicher, dass die Zeile vorhanden ist (kommentiert sie ein, falls nötig).
- **`--become --ask-become-pass`**: Führt das Kommando mit erhöhten Rechten aus und fordert nach dem sudo-Passwort.

### Ergebnis
Dieses Kommando deaktiviert die CD/DVD-Quelle in der Datei `/etc/apt/sources.list` auf dem Debian-Host, und Sie können danach problemlos ein Update der Paketlisten durchführen.


